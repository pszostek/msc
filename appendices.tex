\begin{appendices}
%\appendixpage
\noappendicestocpagenum
\addappheadtotoc

\chapter{Description of classification features}
\label{appendix:features}
\newgeometry{left=2cm,right=2cm}
%\begin{landscape}

\begin{longtable}[t!]{l|l|p{9cm}}
\hline
\# & \textbf{Feature Name} & \textbf{Description} \\ \hline
\rownumber & AffiliationFeature & Tells if the zone contains one of the \{``author details'', ``university'', ``department'', ``school'', ``institute'', ``affiliation''\}\\ \hline
\rownumber & AuthorFeature & Tells if a text zone contains a word starting with ``author''\\ \hline
\rownumber & BibinfoFeature & Number of occurences of \{``cite'', ``pages'', ``article'', ``volume'', ``publishing'', ``journal'', ``doi'', ``cite this article'', ``citation'', ``issue'', ``issn''\} \\ \hline
\rownumber & BracketRelativeCount & Ratio of the number of brackets to the number of all characters \\ \hline
\rownumber & BracketedLineRelativeCount & Ratio of number of lines starting with a bracket to the number of all lines\\ \hline
\rownumber & CharCountFeature & Counts number of characters in a zone\\ \hline
\rownumber & CharCountRelativeFeature & Ratio of number of characters in a zone to the number of character on its page\\ \hline
\rownumber & CommaCountFeature & Counts number of commas in a zone\\ \hline
\rownumber & CommaRelativeCountFeature & Ratio of commas to all characters in a zone \\ \hline
\rownumber & ContainsPageNumberFeature & Tells consists of a number or is like ``Page \%d'' or ``page \%d'', where \%d is a number \\ \hline
\rownumber & CuePhrasesRelativeCountFeature & Ratio of cue phrases from \{``although'', ``therefore'', ``therein'', ``hereby'', ``nevertheless'', ``to this end'', ``however'', ``moreover'', ``nonetheles''\} to all words\\ \hline
\rownumber & DateFeature & Tells if the zone contains a string being a date with months expressed as text or as a number, with either European or American order\\ \hline
\rownumber & DigitCountFeature & Number of digits is in the zone\\ \hline
\rownumber & DigitRelativeCountFeature & Ratio of digits to all characters in the zone \\ \hline
\rownumber & DistanceFromNearestNeighbourFeature & Distance to the nearest neighbour zone or returns Double.MAX\_VALUE if there is no other zone on the page\\ \hline
\rownumber & DotCountFeature & Counts number of dots (``.'') in the zone\\ \hline
\rownumber & DotRelativeCountFeature & Ratio of number of dots to all characters in the zone \\ \hline
\rownumber & EmailFeature & Tells if the zone contains a valid e-mail address\\ \hline
\rownumber & EmptySpaceRelativeFeature & Calculates a ratio of the surface taken by the characters' bounding boxes to the area of the zone \\ \hline
\rownumber & FontHeightMeanFeature & Calculates average font size in the zone \\ \hline
\rownumber & FreeSpaceWithinZoneFeature & Difference between zone's area and total area taken by the characters\\ \hline
\rownumber & HeightFeature & Height of a zone\\ \hline
\rownumber & HeightRelativeFeature & Ratio of zone's height to the page's height\\ \hline
\rownumber & HorizontalRelativeProminenceFeature & Area taken by the zone and free area to the West and East of the page. This features tries to fit into the page a bounding box of the same height as the zone and sticking either to neighbour zones or to the page boundaries in E and W\\ \hline
\rownumber & IsAnywhereElseFeature & Tells if this zone is duplicated anywhere in the investigated document \\ \hline
\rownumber & IsFirstPageFeature & Tells if the zone is located on the first page of the document \\ \hline
\rownumber & IsFontBiggerThanNeighboursFeature & Tells whether the font of the zone is bigger than in neighbour zones\\ \hline
\rownumber & IsGreatestFontOnPageFeature & Tells if the zone has the greatest font on the page \\ \hline
\rownumber & IsHighestOnThePageFeature & Tells if the zone is the highest on the page \\ \hline
\rownumber & IsItemizeFeature & Tells if the zone contains any kind of indexing charactersic for section or enumeration numbering \\ \hline
\rownumber & IsWidestOnThePageFeature & Tells if the zone is the widest on the page\\ \hline
\rownumber & IsLastButOnePageFeature & Tells if the zone is located on the last but one page\\ \hline
\rownumber & IsLastPageFeature & Tells if the zone is located on the last page\\ \hline
\rownumber & IsLeftFeature & Tells if the zone is in the left part of the page\\ \hline
\rownumber & IsLongestOnThePageFeature & Tells if the zone contains maximal number of characters among all the zones in the page\\ \hline
\rownumber & IsLowestOnThePageFeature & Tells if the zone is most southern on the page (southern bounding box border is taken into account) \\ \hline
\rownumber & IsOnSurroundingPagesFeature & Tells if the same zone is on the previous or on the next page \\ \hline
\rownumber & IsPageNumberFeature & Tells if a zone is entirely a number \\ \hline
\rownumber & IsRightFeature & Tells if a zone is on the east side of the page\\ \hline
\rownumber & IsSingleWordFeature & Tells if a zone is one word \\ \hline
\rownumber & LastButOneZoneFeature & Tells if the zone is last but one wrt. to the reading order \\ \hline
\rownumber & LineCountFeature & Number of lines in the zone\\ \hline
\rownumber & LineRelativeCountFeature & Ratio of lines in the to all lines on the page\\ \hline
\rownumber & LineHeightMeanFeature & Mean height of the zone\\ \hline
\rownumber & LineWidthMeanFeature & Mean width of the zone's lines\\ \hline
\rownumber & LineXPositionMeanFeature & Mean distance of zone's lines to the zone's bounding box \\ \hline
\rownumber & LineXPositionDiffFeature & The feature looks at the left border of all lines within a zone and finds the most-eastern and most-western among them. A positive difference between these two values is returned\\ \hline
\rownumber & LineXWidthPositionDiffFeature & Difference between mean value of lines' left border X coordinate and zone's  \\ \hline
\rownumber & LetterCountFeature & Number of letters in the zone\\ \hline
\rownumber & LetterRelativeCountFeature & Ratio of letters in the zone to all letters on the page\\ \hline
\rownumber & LowercaseCountFeature & Number of letters in lower case in the zone\\ \hline
\rownumber & LowercaseRelativeCountFeature & Number of letters in lower case in the zone\\ \hline
\rownumber & PageNumberFeature & Page number wrt. the reading order \\ \hline
\rownumber & PreviousZoneFeature & Value of label assigned to the previous zone wrt. the reading order\\ \hline
\rownumber & ProportionsFeature & Width to height ratio\\ \hline
\rownumber & PunctuationRelativeCountFeature & Ratio of punctuation marks to all characters in the zone\\ \hline
\rownumber & ReferencesFeature & Number of characteristic enumeration indices in the zone, e.g. ``1.''.\\ \hline
\rownumber & StartsWithDigitFeature & Tells if the zone's first character is a digit\\ \hline
\rownumber & UppercaseCountFeature & Number of upper case characters in the zone \\ \hline
\rownumber & UppercaseRelativeCountFeature & Ratio of upper case letters to all characters\\ \hline
\rownumber & UppercaseWordCountFeature & Number of words starting with upper case\\ \hline
\rownumber & UppercaseWordRelativeCountFeature & Ratio of upper case words to all words\\ \hline
\rownumber & VerticalProminenceFeature & Space taken by the zone and free area to the North and South of the page. This features tries to fit into the page a bounding box of the same height as the zone and sticking either to neighbour zones or to the page boundaries in N and S \\ \hline
\rownumber & WidthFeature & Width of the bounding box in pixels\\ \hline
\rownumber & WordCountFeature & Number of words in the zone\\ \hline
\rownumber & WordCountRelativeFeature & Ratio of number of words in the zone to all words in the page\\ \hline
\rownumber & WordWidthMeanFeature & Mean width of words in the zone expressed as pixels\\ \hline
\rownumber & WordLengthMeanFeature & Mean width of words in the zone expressed as number of characters\\ \hline
\rownumber & WordLengthMedianFeature & Median of number of characters in all words \\ \hline
\rownumber & WhitespaceCountFeature & Number of white characters in the text\\ \hline
\rownumber & WhitespaceRelativeCountLogFeature & Feature calculated as $-log \frac{S}{L}$ where $S$ is zone's empty area and $L$ is zone's text length \\ \hline
\rownumber & WidthRelativeFeature & Ratio of zone's width to page's width\\ \hline
\rownumber & XPositionFeature & X coordinate\\ \hline
\rownumber & XPositionRelativeFeature & Ratio of zone's X coordinate to page's width \\ \hline
\rownumber & YPositionFeature & Y coordinate \\ \hline
\rownumber & YPositionRelativeFeature & Ratio of zone's Y coordinate to page's height \\ \hline
\end{longtable}
\restoregeometry
\setcounter{magicrownumbers}{0}

\chapter{Reading order resolving} \label{appendix:ror}
\begin{lstlisting}
public class HierarchicalReadingOrderResolver implements ReadingOrderResolver {

    static final int GRIDSIZE = 50;
    static final double BOXES_FLOW = 0.5;
    static final double EPS = 0.0001;
    static final int MAX_ZONES = 1000;
    static final Comparator<BxObject> Y_ASCENDING_ORDER = new Comparator<BxObject>() {

        @Override
        public int compare(BxObject o1, BxObject o2) {
        	if((o1.getY() - o2.getY()) > EPS ) {
        		return 1;
        	} else if(Math.abs(o1.getY() - o2.getY()) < EPS) {
        		return 0;
        	} else {
        		return -1;
        	}
        }
    };

    static final Comparator<BxObject> X_ASCENDING_ORDER = new Comparator<BxObject>() {

        @Override
        public int compare(BxObject o1, BxObject o2) {
        	if(o1.getX()-o2.getX() > EPS) {
        		return 1;
        	} else if(Math.abs(o1.getX() - o2.getX()) < EPS) {
        		return 0;
        	} else {
        		return -1;
        	}
        }
    };
    
    static final Comparator<BxObject> YX_ASCENDING_ORDER = new Comparator<BxObject>() {

        @Override
        public int compare(BxObject o1, BxObject o2) {
            int yCompare = Y_ASCENDING_ORDER.compare(o1, o2);
            return yCompare == 0 ? X_ASCENDING_ORDER.compare(o1, o2) : yCompare;
        }
    };

    @Override
    public BxDocument resolve(BxDocument messyDoc) {
        BxDocument orderedDoc = new BxDocument();
        List<BxPage> pages = messyDoc.getPages();
        for (BxPage page : pages) {
            List<BxZone> zones = page.getZones();
            for (BxZone zone : zones) {
                List<BxLine> lines = zone.getLines();
                for (BxLine line : lines) {
                    List<BxWord> words = line.getWords();
                    for (BxWord word : words) {
                        List<BxChunk> chunks = word.getChunks();
                        Collections.sort(chunks, X_ASCENDING_ORDER);
                    }
                    Collections.sort(words, X_ASCENDING_ORDER);
                }
                Collections.sort(lines, Y_ASCENDING_ORDER);
            }
            List<BxZone> orderedZones;
            if (zones.size() > MAX_ZONES) {
                orderedZones = new ArrayList<BxZone>(zones);
                Collections.sort(orderedZones, YX_ASCENDING_ORDER);
            } else {
                orderedZones = reorderZones(zones);
            }
            page.setZones(orderedZones);
            orderedDoc.addPage(page);
        }
        setIdsAndLinkTogether(orderedDoc);
        return orderedDoc;
    }

    /**
     * Builds a binary tree from list of text zones by doing a hierarchical clustering and converting the result tree to
     * an ordered list.
     *
     * @param zones is a list of unordered zones
     * @return a list of ordered zones
     */
    private List<BxZone> reorderZones(List<BxZone> unorderedZones) {
        if (unorderedZones.isEmpty()) {
            return new ArrayList<BxZone>();
        } else if (unorderedZones.size() == 1) {
            List<BxZone> ret = new ArrayList<BxZone>(1);
            ret.add(unorderedZones.get(0));
            return ret;
        } else {
            BxZoneGroup bxZonesTree = groupZonesHierarchically(unorderedZones);
            sortGroupedZones(bxZonesTree);
            TreeToListConverter treeConverter = new TreeToListConverter();
            List<BxZone> orderedZones = treeConverter.convertToList(bxZonesTree);
            assert unorderedZones.size() == orderedZones.size();
            return orderedZones;
        }
    }

    /**
     * Generic function for setting IDs and creating a linked list by filling references. Used solely by
     * setIdsAndLinkTogether(). Can Handle all classes implementing Indexable interface.
     *
     * @param list is a list of Indexable objects
     */
    private <A extends Indexable<A>> void setIdsGenericImpl(List<A> list) {
        if (list.isEmpty()) {
            return;
        }
        if (list.size() == 1) {
            A elem = list.get(0);
            elem.setNext(null);
            elem.setPrev(null);
            elem.setId("0");
            elem.setNextId("-1");
            return;
        }

        //unroll the loop for the first and last element
        A firstElem = list.get(0);
        firstElem.setId("0");
        firstElem.setNextId("1");
        firstElem.setNext(list.get(1));
        firstElem.setPrev(null);
        for (int idx = 1; idx < list.size() - 1; ++idx) {
            A elem = list.get(idx);
            elem.setId(Integer.toString(idx));
            elem.setNextId(Integer.toString(idx + 1));
            elem.setNext(list.get(idx + 1));
            elem.setPrev(list.get(idx - 1));
        }
        A lastElem = list.get(list.size() - 1);
        lastElem.setId(Integer.toString(list.size() - 1));
        lastElem.setNextId("-1");
        lastElem.setNext(null);
        lastElem.setPrev(list.get(list.size() - 2));
    }

    /**
     * Function for setting up indices and reference for the linked list. Causes objects of BxPage, BxZone, BxLine,
     * BxWord and BxChunk to be included in the document's list of elements and sets indices according to the
     * corresponding list order.
     *
     * @param doc is a reference to a document with properly set reading order
     */
    private void setIdsAndLinkTogether(BxDocument doc) {
        setIdsGenericImpl(doc.asPages());
        setIdsGenericImpl(doc.asZones());
        setIdsGenericImpl(doc.asLines());
        setIdsGenericImpl(doc.asWords());
        setIdsGenericImpl(doc.asChunks());
    }

    /**
     * Builds a binary tree of zones and groups of zones from a list of unordered zones. This is done in hierarchical
     * clustering by joining two least distant nodes. Distance is calculated in the distance() method.
     *
     * @param zones is a list of unordered zones
     * @return root of the zones clustered in a tree
     */
    private BxZoneGroup groupZonesHierarchically(List<BxZone> zones) {
        /*
         * Distance tuples are stored sorted by ascending distance value
         */
        List<DistElem<BxObject>> dists = new ArrayList<DistElem<BxObject>>(zones.size()*zones.size()/2);
        for (int idx1 = 0; idx1 < zones.size(); ++idx1) {
            for (int idx2 = idx1 + 1; idx2 < zones.size(); ++idx2) {
                BxZone zone1 = zones.get(idx1);
                BxZone zone2 = zones.get(idx2);
                dists.add(new DistElem<BxObject>(false, distance(zone1, zone2),
                        zone1, zone2));
            }
        }
        Collections.sort(dists);
        DocumentPlane plane = new DocumentPlane(zones, GRIDSIZE);
        while (!dists.isEmpty()) {
            DistElem<BxObject> distElem = dists.get(0);
            dists.remove(0);
            if (!distElem.isC() && plane.anyObjectsBetween(distElem.getObj1(), distElem.getObj2())) {
                dists.add(new DistElem<BxObject>(true, distElem.getDist(), distElem.getObj1(), distElem.getObj2()));
                continue;
            }

            BxZoneGroup newGroup = new BxZoneGroup(distElem.getObj1(), distElem.getObj2());
            plane.remove(distElem.getObj1()).remove(distElem.getObj2());
            dists = removeDistElementsContainingObject(dists, distElem.getObj1());
            dists = removeDistElementsContainingObject(dists, distElem.getObj2());
            for (BxObject other : plane.getObjects()) {
                dists.add(new DistElem<BxObject>(false, distance(other,
                        newGroup), newGroup, other));
            }
            Collections.sort(dists);
            plane.add(newGroup);
        }
        
        assert plane.getObjects().size() == 1 : "There should be one object left at the plane after grouping";
        return (BxZoneGroup) plane.getObjects().get(0);
    }

    /**
     * Removes all distance tuples containing obj
     */
    private List<DistElem<BxObject>> removeDistElementsContainingObject(Collection<DistElem<BxObject>> list, BxObject obj) {
        List<DistElem<BxObject>> ret = new ArrayList<DistElem<BxObject>>();
        for (DistElem<BxObject> distElem : list) {
            if (distElem.getObj1() != obj && distElem.getObj2() != obj) {
                ret.add(distElem);
            }
        }
        return ret;
    }

    /**
     * Swaps children of BxZoneGroup if necessary. A group with smaller sort factor is placed to the left (leftChild).
     * An object with greater sort factor is placed on the right (rightChild). This plays an important role when
     * traversing the tree in conversion to a one dimensional list.
     *
     * @param group
     */
    private void sortGroupedZones(BxZoneGroup group) {
        BxObject leftChild = group.getLeftChild();
        BxObject rightChild = group.getRightChild();
        if (shouldBeSwapped(leftChild, rightChild)) {
            // swap
            group.setLeftChild(rightChild);
            group.setRightChild(leftChild);
        }
        
        if (leftChild instanceof BxZoneGroup) // if the child is a tree node, then recurse
        {
            sortGroupedZones((BxZoneGroup) leftChild);
        }
        if (rightChild instanceof BxZoneGroup) // as above - recurse
        {
            sortGroupedZones((BxZoneGroup) rightChild);
        }
    }

    private boolean shouldBeSwapped(BxObject first, BxObject second) {
        double cx, cy, cw, ch, ox, oy, ow, oh;
        cx = first.getBounds().getX();
        cy = first.getBounds().getY();
        cw = first.getBounds().getWidth();
        ch = first.getBounds().getHeight();

        ox = second.getBounds().getX();
        oy = second.getBounds().getY();
        ow = second.getBounds().getWidth();
        oh = second.getBounds().getHeight();

        // Determine Octant
        //
        // 0 | 1 | 2
        // __|___|__
        // 7 | 9 | 3   First is placed in 9th square
        // __|___|__
        // 6 | 5 | 4

        if (cx + cw <= ox) { //2,3,4
        	return false; 
        } else if (ox + ow <= cx) { //0,6,7
        	return true; //6
        } else if (cy + ch <= oy) {
            return false; //5
        } else if (oy + oh <= cy) {
            return true; //1
        } else { //two zones
            double xdiff = ox+ow/2 - cx-cw/2;
            double ydiff = oy+oh/2 - cy-ch/2;
            if (xdiff + ydiff < 0) {
                return true;
            }
            return false;
        }
    }

    /**
     * A distance function between two TextBoxes.
     *
     * Consider the bounding rectangle for obj1 and obj2. Return its area minus the areas of obj1 and obj2, shown as
     * 'www' below. This value may be negative. 
     *         (x0,y0) +------+wwwwwwwwwwwwwwwwww 
     *                 | obj1 |wwwwwwwwwwwwwwwwww
     *                 +------+wwwwwwwwww+------+
     *                 wwwwwwwwwwwwwwwwww| obj2 |
     *                 wwwwwwwwwwwwwwwwww+------+ (x1,y1)
     *
     * @return distance value based on objects' coordinates and physical size on a plane
     *
     */
    private double distance(BxObject obj1, BxObject obj2) {

        double x0 = Math.min(obj1.getX(), obj2.getX());
        double y0 = Math.min(obj1.getY(), obj2.getY());
        double x1 = Math.max(obj1.getX() + obj1.getWidth(),
                obj2.getX() + obj2.getWidth());
        double y1 = Math.max(obj1.getY() + obj1.getHeight(),
                obj2.getY() + obj2.getHeight());
        double dist = ((x1 - x0) * (y1 - y0) - obj1.getArea() - obj2.getArea());

        double obj1CenterX = obj1.getX();
        double obj1CenterY = obj1.getY() + obj1.getHeight() / 2;
        double obj2CenterX = obj2.getX();
        double obj2CenterY = obj2.getY() + obj2.getHeight() / 2;

        double obj1obj2VectorCosineAbs = Math.abs((obj2CenterX - obj1CenterX) / Math.sqrt((obj2CenterX - obj1CenterX) * (obj2CenterX - obj1CenterX) + (obj2CenterY - obj1CenterY) * (obj2CenterY - obj1CenterY)));
        final double MAGIC_COEFF = 0.5;
        return dist * (MAGIC_COEFF + obj1obj2VectorCosineAbs);
    }
}
\end{lstlisting}

\end{appendices}